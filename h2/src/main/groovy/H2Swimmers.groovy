/*
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import groovy.sql.Sql
import org.h2.Driver

var url = "jdbc:h2:mem:swimming;DB_CLOSE_DELAY=-1"
Sql.withInstance(url, "sa", "sa", Driver.name) { sql ->
    sql.execute '''
    DROP TABLE Swimmer IF EXISTS;
    CREATE TABLE Swimmer (
        swimmerId INTEGER GENERATED BY DEFAULT AS IDENTITY,
        name    VARCHAR(64),
        country VARCHAR(64),
        PRIMARY KEY(swimmerId)
    );
    DROP INDEX SwimmerIdx IF EXISTS;
    CREATE INDEX SwimmerIdx ON Swimmer(swimmerId);
    '''
    sql.execute '''
    DROP TABLE Swim IF EXISTS;
    CREATE TABLE Swim (
        swimId INTEGER GENERATED BY DEFAULT AS IDENTITY,
        at     VARCHAR(64),
        event  VARCHAR(64),
        result VARCHAR(64),
        time   NUMERIC(12, 2),
        PRIMARY KEY(swimId)
    );
    DROP INDEX SwimIdx IF EXISTS;
    CREATE INDEX SwimIdx ON Swim(swimId);
    '''
    sql.execute '''
    DROP TABLE Swimmer_Swim IF EXISTS;
    CREATE TABLE Swimmer_Swim (
        fkSwimmer INTEGER,
        fkSwim    INTEGER,
        PRIMARY KEY (fkSwimmer, fkSwim),
        CONSTRAINT fk1 FOREIGN KEY (fkSwimmer)
            REFERENCES Swimmer (swimmerId) ON DELETE CASCADE,
        CONSTRAINT fk2 FOREIGN KEY (fkSwim)
            REFERENCES Swim (swimId) ON DELETE CASCADE
    )
    '''
    sql.execute '''
    DROP TABLE Supersedes IF EXISTS;
    CREATE TABLE Supersedes (
        fkOld INTEGER,
        fkNew INTEGER,
        PRIMARY KEY (fkOld, fkNew),
        CONSTRAINT fk3 FOREIGN KEY (fkOld)
            REFERENCES Swim (swimId) ON DELETE CASCADE,
        CONSTRAINT fk4 FOREIGN KEY (fkNew)
            REFERENCES Swim (swimId) ON DELETE CASCADE
    )
    '''
    var swimmers = [
        ['Emily Seebohm', 'ðŸ‡¦ðŸ‡º'],
        ['Kylie Masse', 'ðŸ‡¨ðŸ‡¦'],
        ['Regan Smith', 'ðŸ‡ºðŸ‡¸'],
        ['Kaylee McKeown', 'ðŸ‡¦ðŸ‡º'],
        ['Katharine Berkoff', 'ðŸ‡ºðŸ‡¸']
    ]

    var (es, km, rs, kmk, kb) = swimmers.collect { name, country ->
        sql.executeInsert("INSERT INTO Swimmer (name, country) VALUES ($name, $country)")[0][0]
    }

    var swims = [
        ['London 2012', 'Heat 4', 58.23, 'First', es],
        ['Tokyo 2021', 'Heat 4', 58.17, 'First', km],
        ['Tokyo 2021', 'Final', 57.72, 'ðŸ¥ˆ', km],
        ['Tokyo 2021', 'Heat 5', 57.96, 'First', rs],
        ['Tokyo 2021', 'Semifinal 1', 57.86, 'First', rs],
        ['Tokyo 2021', 'Final', 58.05, 'ðŸ¥‰', rs],
        ['Paris 2024', 'Final', 57.66, 'ðŸ¥ˆ', rs],
        ['Paris 2024', 'Relay leg1', 57.28, 'First', rs],
        ['Tokyo 2021', 'Heat 6', 57.88, 'First', kmk],
        ['Tokyo 2021', 'Final', 57.47, 'ðŸ¥‡', kmk],
        ['Paris 2024', 'Final', 57.33, 'ðŸ¥‡', kmk],
        ['Paris 2024', 'Final', 57.98, 'ðŸ¥‰', kb]
    ]

    var swimIndexes = swims.collect { at, event, time, result, swimmerIndex ->
        var swimIndex = sql.executeInsert("""
            INSERT INTO Swim (at, event, time, result)
            VALUES ($at, $event, $time, $result)
        """)[0][0]
        sql.executeInsert "INSERT INTO Swimmer_Swim (fkSwimmer, fkSwim) VALUES ($swimmerIndex, $swimIndex)"
        swimIndex
    }

    assert sql.rows( """
        SELECT DISTINCT country FROM Swimmer
        LEFT JOIN Swimmer_Swim
            ON Swimmer.swimmerId = Swimmer_Swim.fkSwimmer
        LEFT JOIN Swim
            ON Swim.swimId = Swimmer_Swim.fkSwim
        WHERE Swim.at = 'Paris 2024'
    """)*.COUNTRY.toSet() == ['ðŸ‡¦ðŸ‡º', 'ðŸ‡ºðŸ‡¸'] as Set

    [
        [swimIndexes[1], swimIndexes[0]],
        [swimIndexes[3], swimIndexes[1]],
        [swimIndexes[8], swimIndexes[3]],
        [swimIndexes[4], swimIndexes[8]],
        [swimIndexes[9], swimIndexes[4]],
        [swimIndexes[10], swimIndexes[9]],
        [swimIndexes[7], swimIndexes[10]]
    ].each { newS, oldS ->
        sql.executeInsert """
            INSERT INTO Supersedes (fkOld, fkNew) VALUES ($oldS, $newS)
        """
    }

    assert sql.rows( """
        SELECT time FROM Swim
        INNER JOIN Supersedes
            ON Swim.swimId = Supersedes.fkNew
        WHERE Swim.event = 'Final'
    """)*.TIME.toSet() == [57.47, 57.33] as Set

    assert sql.rows( """
        SELECT at FROM Swim
        INNER JOIN Supersedes
            ON Swim.swimId = Supersedes.fkOld
        WHERE left(Swim.event, 4) ='Heat'
    """)*.AT.unique().sort() == ['London 2012', 'Tokyo 2021']

    sql.eachRow( """
        WITH RECURSIVE traversed(swimId) AS (
            SELECT fkNew FROM Supersedes
            WHERE fkOld IN (
                SELECT swimId FROM Swim
                WHERE event = 'Heat 4' AND at = 'London 2012'
            )
            UNION ALL
            SELECT Supersedes.fkNew as swimId
            FROM traversed as t
                JOIN Supersedes
                    ON t.swimId = Supersedes.fkOld
            WHERE t.swimId = swimId
        )
        SELECT at, event FROM Swim
        WHERE swimId IN (SELECT * FROM traversed)
    """) {
        println "$it.AT $it.EVENT"
    }
}
